[
  
    {
      "title"    : "Mastering Layouts in Phoenix for Elixir LiveView Apps",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/mastering-layouts-in-elixir'>Mastering Layouts in Phoenix for Elixir LiveView Apps<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2024-05-22T14:01:35+02:00'>22 May 2024</time> – <span class='article__minutes'>3min read</span> </div><p class='article__excerpt'>Discover the versatility of Phoenix Layouts for structuring your Elixir LiveView applications. Learn how to enhance your web development process with Phoenix Layouts today!</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a><a href='/tag/liveview' class='article__tag'>liveview</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir and liveview",
      "url"      : "/mastering-layouts-in-elixir",
      "date"     : "2024-05-22 14:01:35 +0200",
      "content"  : "Phoenix Layouts offer a powerful way to structure your Elixir LiveView application. From simple, static pages to complex, real-time user interactions, layouts cover a vast spectrum of possibilities. But how well do you understand these layout options and when to use them? Let’s explore!Introduction to Elixir LiveViewElixir’s LiveView is a revolutionary tool that empowers developers to build interactive, real-time applications without the need for JavaScript. When integrated with Phoenix, it opens a world of opportunities, one of which includes multiple layout options.Phoenix Layouts UnveiledIn a Phoenix application, layouts are akin to templates that determine the structure and appearance of web pages. They enable code reusability, maintain consistent design across pages, and can even adapt dynamically to pop-out sections such as a sidebar or a navigation bar.Mapping the Phoenix Layout LandscapePhoenix provides several layout choices: the root layout, the normal layout, live layouts, and page-specific layouts.The Root LayoutThe root layout serves as a parent template for all pages in the application. It proves particularly useful for sections of your app that remain constant, such as headers or footers.# Setting the root layout in live_view router defmodule MyAppWeb.Router do   use MyAppWeb, :router   pipeline :browser do    ...    plug :put_root_layout, {MyAppWeb.LayoutView, "root.html"}   end   ... endIn this example, root.html is the root layout for all LiveViews, and it remains static across all pages.The Normal LayoutThe normal layout is usually used for static content. It is ideal for delivering a consistent appearance across non-live or static pages.# lib/my_app_web/layout_view.exdefmodule MyAppWeb.LayoutView do  use Phoenix.View  def render("app.html", assigns) do    ~L"""      ...      &lt;main role='main'&gt;       &lt;%= render @view_module, @view_template, assigns %&gt;      &lt;/main&gt;      ...    """    end  endIn app.html.leex, the dynamic content is rendered within the &lt;main&gt; tag in line with our layout’s design.Live LayoutsLive Layouts are ideal for delivering real-time, dynamic content. Below you can see a LiveLayout example for a chat application:# lib/my_app_web/live/live_layout.exdefmodule MyAppWeb.LiveLayout do  use MyAppWeb, :live_layout  def render(assigns) do    ~L"""      &lt;div class="chat-container"&gt;        &lt;%= live_render(@socket, MyAppWeb.UserListLive) %&gt;        &lt;%= @inner_content %&gt;      &lt;/div&gt;    """  endendThe UserListLive LiveView is always rendered in the chat container irrespective of which LiveView is shown on the right.Page-specific LayoutsPage-specific layouts let you define a particular layout for individual pages.# lib/my_app_web/live/product_live/show.exdefmodule MyAppWeb.ProductLive.Show do ... @layout {MyAppWeb.LayoutView, :product} ...endHere, we defined a layout specifically for the Product page view.Challenge Conquered: Combining live_session with LayoutsPhoenix also lets you define a layout within a live_session. This is especially useful if you want all LiveViews within the session to use the same LiveLayout.# lib/my_app_web/router.exdefmodule MyAppWeb.Router do ... live_session :session, layout: {MyAppWeb.LayoutView, :session} do   live "/dashboard", DashboardLive   live "/profile", ProfileLive end ...endIn this snippet, both DashboardLive and ProfileLive would utilize the same :session layout.Exploring these different layout options, we see Phoenix Layouts provide flexibility to structure your Elixir LiveView apps. Remember, the goal is not to use all layout options, but to use the right layout options where they fit best."
    } ,
  
    {
      "title"    : "Building Efficient ETL Pipelines with Elixir &amp; GenStage: A Comprehensive Guide",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/etl-data-pipelines-in-elixir'>Building Efficient ETL Pipelines with Elixir &amp; GenStage: A Comprehensive Guide<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2022-10-15T14:01:35+02:00'>15 October 2022</time> – <span class='article__minutes'>10min read</span> </div><p class='article__excerpt'>This guide details how to build efficient, concurrent ETL pipelines using Elixir and GenStage, offering insights into data validation and processing to enhance your data-driven applications.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a><a href='/tag/etl' class='article__tag'>etl</a><a href='/tag/genstage' class='article__tag'>genstage</a><a href='/tag/data-processing' class='article__tag'>data-processing</a><a href='/tag/concurrent-pipelines' class='article__tag'>concurrent-pipelines</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir, etl, genstage, data-processing, and concurrent-pipelines",
      "url"      : "/etl-data-pipelines-in-elixir",
      "date"     : "2022-10-15 14:01:35 +0200",
      "content"  : "Let’s dive into how Elixir, a programming language known for handling tasks simultaneously and efficiently, works perfectly with GenStage to manage data operations - the heart of any data-focused project. In this easy-to-follow guide, we’re going to have some fun as we use our keyboards to create a real-time data processing pipeline with Elixir and GenStage.Transforming Data the Elixir WayTo understand how powerful working with Elixir is, we first need to introduce some common source data. In this example, we will use trial data generated from a fake log stream, populating it in real time.defmodule LogStream do      def start_link do        # log stream generates a new log entry every 1 second        Task.start_link(fn -&gt; generate_logs() end)    end    defp generate_logs do        Stream.cycle(["INFO", "WARN", "ERROR"])        |&gt; Stream.zip(Stream.interval(1_000))        |&gt; Enum.each(fn {level, _} -&gt; IO.puts("#{timestamp()} #{level} some interesting log...") end)    end    defp timestamp do        DateTime.now |&gt; DateTime.to_string    end  endendLog entries will be formatted as:"{current timestamp} {log level} some interesting log..."A Deeper Dive into GenStage for Data Extraction in ElixirIntroduced in Elixir 1.3, GenStage is a behavior abstraction for working with Producer and Consumer models, offering back-pressure and other complex features essential for high-volume data processing tasks like ETL. GenStage was built to support data-flow computations like concurrent processing, queuing, staged processing, and system event handling among others.Understanding Producer/Consumer Dynamics in GenStageIn the GenStage parlance, the producer sends data downstream while the consumer receives data upstream. Work is scheduled at the optimal pace, offering mechanisms to regulate the flow of data and prevent overloading.Three main roles bring a GenStage system to life:  Producer: Source of events. It offers a subscription mechanism for other stages to attach.  Consumer: Sink of events. It holds subscriptions to producers and consumes their data.  Producer-Consumer: A hybrid role, it works as both a consumer to a producer and a producer to a consumer, enabling chaining between stages.We introduce Elixir’s GenStage by setting up a producer that continuously reads from our log stream. This producer will be the basis of our extraction process in our ETL workflow.defmodule LogProducer do  use GenStage  def start_link do    GenStage.start_link(__MODULE__, :ok, name: __MODULE__)  end  def init(:ok) do    {:producer, [], dispatcher: GenStage.BroadcastDispatcher}  end  def handle_call({:push_log, log}, _from, state) do    # the log will be pushed to all consumers    {:reply, :ok, [log], state}  endendWe set up the dispatcher as GenStage.BroadcastDispatcher to ensure the log is sent to all consumers, not just one.Transforming Data with Multiple GenStage Producers/ConsumersOur log stream will be loaded with different log levels, and we want to process them separately. For that, we create a GenStage producer/consumer for each log level.defmodule LogProcessor do  use GenStage  def start_link(log_level) do    GenStage.start_link(__MODULE__, log_level, name: String.to_atom("LogProcessor.\#{log_level}"))  end  def init(log_level) do    GenStage.sync_subscribe(self(), to: LogProducer, max_demand: 1)    {:producer_consumer, log_level}  end  def handle_events([log], _from, log_level) do    [timestamp, level, message] = String.split(log)    if level === log_level do      IO.puts "Processing \#{log_level} log..."      # Here is where the actual transformation would happen      # For now, just print out the message part      IO.puts message    end    # log is processed, ask for next log    {:noreply, [], log_level}  endendLoading Data with GenStage ConsumersVanilla GenStage consumers suit the loading component after the data has been through the extraction and transformation stages. We will set up one consumer that subscribes to all transformed log streams.defmodule LogConsumer do  use GenStage  def start_link do    GenStage.start_link(__MODULE__, :ok, name: __MODULE__)  end  def init(:ok) do    Enum.each(~w(INFO WARN ERROR), fn level -&gt;      GenStage.sync_subscribe(self(), to: String.to_atom("LogProcessor.#{level}"), max_demand: 1)    end)    {:consumer, nil}  end  def handle_events(logs, _from, state) do    # Actual implementation of loading log to the final destination would go here    # For now, just print out the length of the logs    IO.puts("Loaded: #{length(logs)} logs")    {:noreply, [], state}  endendEnsuring Data Validity and Consistency with ElixirData validation and consistency checks are critical stages in any ETL (Extract, Transform, Load) pipeline. Without these, the data delivered at the end of the pipeline could be unreliable or even misleading. Fortunately, Elixir provides multiple approaches to ensure data validity and consistency, making it well-suited to ETL operations.Data Consistency with ElixirEnsuring data consistency typically involves verifying that the data adheres to defined rules or schemas. Elixir provides solutions like Structs and the Ecto library for such challenges.  Structs, in Elixir, provide a way of defining custom data types with pre-set values and validations where necessary.Here’s a simple example of defining a struct for a log entry:defmodule LogEntry do  defstruct level: "INFO", message: "", timestamp: DateTime.utc_nowendA struct ensures that each LogEntry must contain these fields and automatically assigns them default values if none are provided.  Ecto, on the other hand, is a database wrapper and a fantastic query builder. It also provides a powerful system for data mapping and validation called Changesets.Imagine adding a Changeset to our data entry to ensure that each log message is a non-empty string. Here’s what that might look like:defmodule LogEntry do  use Ecto.Schema    @enforce_keys [:timestamp, :level, :message]  defstruct [:timestamp, :level, :message]    import Ecto.Changeset    def changeset(entry, params \\ %{}) do    entry    |&gt; cast(params, [:timestamp, :level, :message])    |&gt; validate_required([:timestamp, :level, :message])    |&gt; validate_length(:message, min: 1)  endendData Validation in Elixir with Custom ValidatorsFor more complex rules that can’t be satisfied with built-in validators, Elixir also allows us to write custom validator functions.Consider the need for the message to be at least 10 characters and to always begin with the phrase “Log Entry: “. A custom validator for this requirement would look as follows:def validate_message_format(changeset) do  validate_change(changeset, :message, fn :message, message -&gt;    if message =~ ~r/^Log Entry: .{10,}$/ do      []    else      [{:message, "must begin with 'Log Entry: ' and be at least 10 characters long"}]    end  end)endThe function validate_change takes the changeset and the attribute to be validated as arguments, and if the changed value doesn’t match the prescribed pattern, it returns an appropriate error message.Implementing these techniques in your ETL pipeline will ensure data coming out of your ETL pipeline follows the specified format rules and contains valid entries.The Benefit of Being AsynchronousGenStage takes the concurrency built into Elixir and capitalizes on it, offering a series of abstractions to manage the concurrency across different stages of a data processing pipeline.GenStage works by splitting the roles into stages, with each stage acting as a mini-application, handling its own data processing and passing on the results to the next stage. Asynchronous here means each stage works independently and in conjunction with each other stage.Comfortably handling back-pressure or the build-up of data at any stage is GenStage’s selling point. For example, if the consuming stage can’t keep up with the producing stage, GenStage reduces the load sent to the consumer, preventing data flow issues, a feature lacking in central-thread languages like Ruby, where one thread handles multiple actions sequentially.Why GenStage Over Single-Threading/Multi-ThreadingThe preference arises from the flexibility and performance GenStage offers.  Speed &amp; Efficiency: GenStage’s asynchronous nature means all available CPU resources are efficiently used. This approach delivers a notable speed advantage over single-threaded languages.  Resilience &amp; Fault Tolerance: Unlike typical scenarios in a multithreaded environment, if one Elixir (GenStage) process fails, it doesn’t crash the entire application. Elixir’s support for advanced features like Supervisor trees makes it resilient against failures.  Scalability: When it comes to scalability, GenStage outperforms both single-threaded and multi-threaded languages. GenStage efficiently handles a large number of processes without a torrent of threads overburdening the system resources.ConclusionThis guide only scratches the surface of Elixir’s powerful concurrency and GenStage’s reliable back-pressure handling.I like to hear more about how you’ve managed your ETL needs, particularly data consistency and validation, with Elixir. Share your ways, passionate thoughts, and experiences with me!Additional Resources  Elixir Official Documentation  GenStage GitHub Repository  Real-time Data Processing with GenStage: A practical example of building real-time data pipelines with GenStage.  What is ETL?: Learn about ETL processes, their importance, and how they are implemented.  ETL Best Practices: Best practices for building ETL pipelines."
    } ,
  
    {
      "title"    : "Polymorphism in Elixir part-1",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/elixir-protocols-explained-part-1'>Polymorphism in Elixir part-1<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2022-01-10T13:01:35+01:00'>10 January 2022</time> – <span class='article__minutes'>4min read</span> </div><p class='article__excerpt'>This guide introduces polymorphism in Elixir through protocols, offering a foundational understanding of how Elixir enables flexible code interaction across different data types, setting the stage for practical protocol implementation.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a><a href='/tag/protocols' class='article__tag'>protocols</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir and protocols",
      "url"      : "/elixir-protocols-explained-part-1",
      "date"     : "2022-01-10 13:01:35 +0100",
      "content"  : "In today’s post, we’re going to explore the concept of protocols in depth. Unlike object-oriented applications, where inheritance is a key architectural element, functional applications, such as those built with Elixir and Erlang, don’t rely on inheritance in the same way. This is because the Elixir and Erlang runtime environments don’t incorporate the concept of inheritance into their data structures. However, this doesn’t mean they lack advanced concepts altogether.Polymorphism in Other LanguagesObject-oriented languages provide you with multiple inheritance or interfaces, allowing you to declare that objects belonging to multiple different classes, and all respond to the same method calls even doe underlying data are completely different.// Rubyclass Truck &lt; Vehicle// Javapublic class Truck implements DrivablePolymorphism in ElixirElixir has several mechanisms that allow us to write expressive and intuitive code. One of them is Protocol.Protocols are a mechanism to achieve polymorphism in Elixir. Creating an Protocol allows us to create our own implementation for our own data.This way a function could accept any data type that implemented a particular protocol, and it would be able to work with that data type.Good part is that it would not have to know anything else about that data type, allowing different data types to put their own spin on a piece of functionality.One of the most popular protocols in 3rd party libraries comes from the Json library, which encodes and decodes JSON data. In library sorce we can find protocal called Json Encoder. It defines single function encode with no definition.defprotocol JSON.Encoder do @moduledoc "..." @type t :: term @type opts :: Json.Encode.opts() @fallback_to_any true @doc "..." @spec encode(t, opts) :: iodata def encode(value, opts)endWhen the Protocol is implemented, other parts of library can call encode() and it will encode that data to JSON.JSON.Encoder.encode() # &lt;- pass in any data (string, integers, maps, list etc..)You may be wondering what is the point of this formality if we could write a function with multiple function heads that’s matches that type of data, likedef encode(value) when is_atom(value) do ...enddef encode(value) when is_binary(value) do ...enddef encode(value) when is_integer(value) do ...endafter all, we have guard classes for most data types in Elixir, the goal is extensibility.Having to implement a protocol for all types may quickly become monotonous and exhausting. You can define fallback behavior for types that don’t implement your protocol by implementing the protocol for Any. Let’s have a look in Json.Encode default implementation.defimpl JSON.Encoder, for: Any do  @moduledoc """  Falllback module for encoding any other values  """  @doc """  Encodes a map into a JSON object  """  def encode(%{} = struct) do    ...  end  def encode(x) do    ...  endendProtocol StructuringWhen it comes to organizing protocols, practices vary. Some developers prefer to keep the protocol in its own separate file, while others choose to include it within the same file as another module. My preferred approach is to maintain a dedicated directory, lib/protocols/, for storing actual protocol definitions. The organization within this directory generally follows the standard pattern, except that it skips the first layer of the namespace. For example, if my protocol is named Foo.Bar, I would place it in lib/protocols/bar.ex. In this directory, I also include the defimpl for all native and foreign data types.As for the protocol implementation, I believe it should be kept as close to the data layer as possible. This means implementing the protocol in the files that define the struct. This approach helps in maintaining a clear and logical structure, ensuring that the protocol implementations are directly associated with the relevant data types.defmodule Foo.Struct do  defstruct some_field: 0  defimpl Foo.Bar do    # actual implementation  endendSince, in the first part of this two-part series, we focused more on the theoretical part related to protocols, in the next part, we will focus more on the practical part and actually, see how the protocols work in reality and how we can implement them."
    } ,
  
    {
      "title"    : "Demistify elixir actor model",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/demistify-elixir-actor-model'>Demistify elixir actor model<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2021-12-01T13:01:35+01:00'>01 December 2021</time> – <span class='article__minutes'>9min read</span> </div><p class='article__excerpt'>Deep dive into what exactly the Actor Model is, and how exactly the Actor Model is implemented in Elixir/Erlang.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a><a href='/tag/actor-model' class='article__tag'>actor-model</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir and actor-model",
      "url"      : "/demistify-elixir-actor-model",
      "date"     : "2021-12-01 13:01:35 +0100",
      "content"  : "In this blog post, I will try to demystify Elixir Actor Model and deep dive into what exactly the Actor Model is, and how exactly the Actor Model is implemented in Elixir/Erlang.To really understand these concepts, we will be writing code snippets to have a deeper understanding of the concept.What is the Actor Model?It’s a conceptual model of concurrent computation that originated in 1973. The actor model is designed to be a message-driven, non-blocking unit of computation. The actor model is not much different than a simple object and they have a few additional mechanisms that allow them to be message-driven and deal with messages that will be sent and delivered in an asynchronous way.An actor can hold its own state and can decide how to process the next message based on that state.The Actor Model is not the only concurrency model outside. Some of them are:     • CSP (Communication Sequential Processes) implemented in GO Language     • STM (Software Transactional Memory) implemented in Haskell     • TT-calculus and others…Actor Model on the BEAMIn the context of the BEAM, an actor is a process (not OS process) running in the Erlang virtual machine.Processes are isolated from each other, run concurrent to one another and communicate via message passing. Each process is compleatly separated from all the other process, it has a separate memory, garbage collector, nearly separate run time and the only way to communicate with the outside world is by sending messages to other processes located locally, or remotely on another connected Node.Messages and Mailboxes    Messages    • Messages in Elixir are asynchronous    • When you send a message to an actor, the message is placed instantly in the actor’s mailbox    • Actor process only one message by the time (FIFO)    Mailboxes    • Mailboxes in Elixir are lock-free queues    • Works asynchronously (doesn’t wait for response from another actor)Actor CreationAn actor is created by using the spawn function or the spawn_link function and it can create also an child actor.SpawnSpawn takes a function and returns a process identifier, aka a PID. The function passed to spawn takes no arguments and its structure is expected to be an infinite loop.All the messages are consumed via a receive block. receive block processes messages in the order received and allows messages to be pattern matched.Messages are sent to the processes using the send/2 function.actor = spawn fn -&gt;  receive do    {sender, :ping} -&gt; "Got ping"  endendsend(actor, {self, :ping}) #=&gt;  Got pingThis example above creates an actor that can only respond to a single message. That message MUST be the tuple {:ping}. Any other message is ignored.When the message {:ping} arrives, the actor prints out “Got ping” and thenthe function of the actor returns. That is interpreted as a normal exit, similar to having the run() method of a Java thread return.spawn_linkSimilar to spawn, spawn_link creates a new process, but links the current and new process so that if one crashes, both processes terminate.Linking processes is crucial  to the Elixir  philosophy of letting programs crash instead of trying to rescue from errors. With linking them we can better interactions with our actors.Linked actors get notified if one of them goes down(by either exiting normally or crashing). To receive this notification, we have to tell the system to trap the exit ofan actor; it then sends us a message in the form: {:EXIT, pid, reason} whenan actor goes down but ONLY if we start the process using spawn_link.Actor StateSince Elixir is immutable, you may be wondering how state is held. Actor state is nothing else than internal actor data, which can beaccessed directly only from an actor-owner. When one actor wants to read the data of another actor, it has to send a message and receive back the state. To maintain state in an actor, we can use pattern matching and recursion.defmodule Counter do def loop(count) do  receive do   {:next} -&gt;     IO.puts("Current count: #{count}")	     loop(count + 1)   end endendcounter = spawn(Counter, :loop, [1]) send(counter, {:next}) =&gt; # Current count: 1 send(counter, {:next}) =&gt; # Current count: 2Actor communicationSince an actor is a isolated process with internal state and mailbox, it has its own PID (process id), which is a unique actor identifier, used for message sender or receiver specification.Message passingFor direct message send it uses send function, which takes two arguments: PID of actor-receiver and the message itself. It runs asynchronously, so after this function invocation, actor will continue its execution.  send(other_actor_pid, message)Message receiveFor message receive it uses receive construction, which includes:    - Pairs &lt;msg pattern 1&gt; -&gt;&lt;related actions&gt;. If next message from mailbox matches to a given pattern, related actions is performed. Otherwise, actor waits for a new message matching to any other pattern    - Statement after, which specifies timeout for message delivery. If no new messages in mailbox in this time, the actor stops waiting and continues execution.defmodule Salutator do  def run do    receive do      {:hi, name} -&gt;        IO.puts "Hi, #{name}      {_, name} -&gt;        IO.puts "Hello, #{name}      after        1_000 -&gt; "nothing after 1s"    end  endend		 pid = spawn(Salutator, :run, [])send(pid, {:hi, "Mark"})  {:hi, "Mark"}=&gt; # Hi, Mark		send(pid, {:hello, "Suzie"})  {:hello, "Suzie"}=&gt; # Hello, SuzieParallelismParallelism means doing the same operations at the exact same time on independant data.In Elixir, processes are separate contexts (isolation) and you can have hundreds of thousands of processes on a single CPU (lightweight). If your computer has multiple cores, Elixir will run processes on each of them in parallel.    • Parallelism in actiondefmodule Parallel do  def map(collection, fun) do    parent = self()        processes = Enum.map(collection, fn(e) -&gt;     spawn_link(fn() -&gt;      send(parent, {self(), fun.(e)})     end)    end)    Enum.map(processes, fn(pid) -&gt;      receive do        {^pid, result} -&gt; result      end    end)  end endLet’s create some “heavy” function that will multiply numbers with one second delay..heavy_double = fn(x) -&gt; :timer.sleep(1000); x * 2 endIn sequential call the delay of one second occurred ten times and so the entire call to Enum.map took 10 seconds.:timer.tc(fn() -&gt; Enum.map([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], heavy_double) end)=&gt;  # {10010165, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]} &lt;= about 10 secondsIn parallel call process got launched per element of the input collection, they all waited one second, and then returned their result, so the entire call to Parallel.map took 1 second.:timer.tc(fn() -&gt; Parallel.map([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], heavy_double) end)=&gt; # {1001096, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]} &lt;= about 1 second Parallelism is fundamentally about taking something you can do in a sequential (one process/thread) program and making it faster by doing parts of it at the same time.SummaryAn actor in Elixir is called a process. You create new processes using one of the variants of the spawn function, send messages to it using the &lt;- operator, and receive messages using a receive expressionProcesses all contain a mailbox where messages are passively kept until consumed via a receive block. Actor State is internal actor data, which can be accessed directly only from an actor-owner. When one actor wants to read the data of another actor, it has to send a message and receive back the state."
    } 
  
]
