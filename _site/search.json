[
  
    {
      "title"    : "Building Concurrent ETL Pipelines with Elixir and GenStage",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/etl-pipelines'>Building Concurrent ETL Pipelines with Elixir and GenStage<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2022-10-15T14:01:35+02:00'>15 October 2022</time> – <span class='article__minutes'>8min read</span> </div><p class='article__excerpt'>Exploring the Advantage with Live Data Streams.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a><a href='/tag/ETL' class='article__tag'>ETL</a><a href='/tag/GenStage' class='article__tag'>GenStage</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir, ETL, and GenStage",
      "url"      : "/etl-pipelines",
      "date"     : "2022-10-15 14:01:35 +0200",
      "content"  : "Elixir, the functional and concurrent programming language, in conjunction with GenStage, its computation pipeline architecture, elegantly lends itself to ETL (Extract, Transform, Load) operations — the bloodstream of data-driven work. In this guide, we’ll roll up our sleeves, bring out our keyboards, and build a live data processing pipeline using Elixir and GenStage.Transforming Data the Elixir Way:To understand how powerful working with Elixir is, we first need to introduce some common source data. In this example, we will use trial data generated from a fake log stream, populating it in real time.defmodule LogStream do      def start_link do        # log stream generates a new log entry every 1 second        Task.start_link(fn -&gt; generate_logs() end)    end    defp generate_logs do        Stream.cycle(["INFO", "WARN", "ERROR"])        |&gt; Stream.zip(Stream.interval(1_000))        |&gt; Enum.each(fn {level, _} -&gt; IO.puts("#{timestamp()} #{level} some interesting log...") end)    end    defp timestamp do        DateTime.now |&gt; DateTime.to_string    end  endendLog entries will be formatted as:"{current timestamp} {log level} some interesting log..."A Deeper Dive into GenStage for Data Extraction in ElixirIntroduced in Elixir 1.3, GenStage is a behavior abstraction for working with Producer and Consumer models, offering back-pressure and other complex features essential for high-volume data processing tasks like ETL. GenStage was built to support data-flow computations like concurrent processing, queuing, staged processing, and system event handling among others.Understanding Producer/Consumer Dynamics in GenStageIn the GenStage parlance, the producer sends data downstream while the consumer receives data upstream. Work is scheduled at the optimal pace, offering mechanisms to regulate the flow of data and prevent overloading.Three main roles bring a GenStage system to life:  Producer: Source of events. It offers a subscription mechanism for other stages to attach.  Consumer: Sink of events. It holds subscriptions to producers and consumes their data.  Producer-Consumer: A hybrid role, it works as both a consumer to a producer and a producer to a consumer, enabling chaining between stages.We introduce Elixir’s GenStage by setting up a producer that continuously reads from our log stream. This producer will be the basis of our extraction process in our ETL workflow.defmodule LogProducer do  use GenStage  def start_link do    GenStage.start_link(__MODULE__, :ok, name: __MODULE__)  end  def init(:ok) do    {:producer, [], dispatcher: GenStage.BroadcastDispatcher}  end  def handle_call({:push_log, log}, _from, state) do    # the log will be pushed to all consumers    {:reply, :ok, [log], state}  endendWe set up the dispatcher as GenStage.BroadcastDispatcher to ensure the log is sent to all consumers, not just one.Transforming Data with Multiple GenStage Producers/ConsumersOur log stream will be loaded with different log levels, and we want to process them separately. For that, we create a GenStage producer/consumer for each log level.defmodule LogProcessor do  use GenStage  def start_link(log_level) do    GenStage.start_link(__MODULE__, log_level, name: String.to_atom("LogProcessor.\#{log_level}"))  end  def init(log_level) do    GenStage.sync_subscribe(self(), to: LogProducer, max_demand: 1)    {:producer_consumer, log_level}  end  def handle_events([log], _from, log_level) do    [timestamp, level, message] = String.split(log)    if level === log_level do      IO.puts "Processing \#{log_level} log..."      # Here is where the actual transformation would happen      # For now, just print out the message part      IO.puts message    end    # log is processed, ask for next log    {:noreply, [], log_level}  endendLoading Data with GenStage ConsumersVanilla GenStage consumers suit the loading component after the data has been through the extraction and transformation stages. We will set up one consumer that subscribes to all transformed log streams.defmodule LogConsumer do  use GenStage  def start_link do    GenStage.start_link(__MODULE__, :ok, name: __MODULE__)  end  def init(:ok) do    Enum.each(~w(INFO WARN ERROR), fn level -&gt;      GenStage.sync_subscribe(self(), to: String.to_atom("LogProcessor.#{level}"), max_demand: 1)    end)    {:consumer, nil}  end  def handle_events(logs, _from, state) do    # Actual implementation of loading log to the final destination would go here    # For now, just print out the length of the logs    IO.puts("Loaded: #{length(logs)} logs")    {:noreply, [], state}  endendEnsuring Data Validity and Consistency with ElixirData validation and consistency checks are critical stages in any ETL (Extract, Transform, Load) pipeline. Without these, the data delivered at the end of the pipeline could be unreliable or even misleading. Fortunately, Elixir provides multiple approaches to ensure data validity and consistency, making it well-suited to ETL operations.Data Consistency with ElixirEnsuring data consistency typically involves verifying that the data adheres to defined rules or schemas. Elixir provides solutions like Structs and the Ecto library for such challenges.  Structs, in Elixir, provide a way of defining custom data types with pre-set values and validations where necessary.Here’s a simple example of defining a struct for a log entry:defmodule LogEntry do  defstruct level: "INFO", message: "", timestamp: DateTime.utc_nowendA struct ensures that each LogEntry must contain these fields and automatically assigns them default values if none are provided.  Ecto, on the other hand, is a database wrapper and a fantastic query builder. It also provides a powerful system for data mapping and validation called Changesets.Imagine adding a Changeset to our data entry to ensure that each log message is a non-empty string. Here’s what that might look like:defmodule LogEntry do  use Ecto.Schema    @enforce_keys [:timestamp, :level, :message]  defstruct [:timestamp, :level, :message]    import Ecto.Changeset    def changeset(entry, params \\ %{}) do    entry    |&gt; cast(params, [:timestamp, :level, :message])    |&gt; validate_required([:timestamp, :level, :message])    |&gt; validate_length(:message, min: 1)  endendData Validation in Elixir with Custom ValidatorsFor more complex rules that can’t be satisfied with built-in validators, Elixir also allows us to write custom validator functions.Consider the need for the message to be at least 10 characters and to always begin with the phrase “Log Entry: “. A custom validator for this requirement would look as follows:def validate_message_format(changeset) do  validate_change(changeset, :message, fn :message, message -&gt;    if message =~ ~r/^Log Entry: .{10,}$/ do      []    else      [{:message, "must begin with 'Log Entry: ' and be at least 10 characters long"}]    end  end)endThe function validate_change takes the changeset and the attribute to be validated as arguments, and if the changed value doesn’t match the prescribed pattern, it returns an appropriate error message.Implementing these techniques in your ETL pipeline will ensure data coming out of your ETL pipeline follows the specified format rules and contains valid entries.This guide only scratches the surface of Elixir’s powerful concurrency and GenStage’s reliable back-pressure handling.I like to hear more about how you’ve managed your ETL needs, particularly data consistency and validation, with Elixir. Share your ways, passionate thoughts, and experiences with us!"
    } ,
  
    {
      "title"    : "Polymorphism in Elixir part-1",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/elixir-protocols-explained-part-1'>Polymorphism in Elixir part-1<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2022-01-10T13:01:35+01:00'>10 January 2022</time> – <span class='article__minutes'>4min read</span> </div><p class='article__excerpt'>Let&#39;s explore how to achieve polymorphism in Elixir.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir",
      "url"      : "/elixir-protocols-explained-part-1",
      "date"     : "2022-01-10 13:01:35 +0100",
      "content"  : "In today’s post, we will deep dive into the potion of protocols. Since inheritance does not play a big role in the architecture of functional applications like it does in object-oriented ones andit’s true that Elixir and Erlang runtime don’t have a concept of inheritance in their data but that doesn’t mean that they don’t have a higher-order concept.Polymorphism in Other LanguagesObject-oriented languages provide you with multiple inheritance or interfaces, allowing you to declare that objects belonging to multiple different classes, and all respond to the same method calls even doe underlying data are completely different.// Rubyclass Truck &lt; Vehicle// Javapublic class Truck implements DrivablePolymorphism in ElixirElixir has several mechanisms that allow us to write expressive and intuitive code. One of them is Protocol.Protocols are a mechanism to achieve polymorphism in Elixir. Creating an Protocol allows us to create our own implementation for our own data.This way a function could accept any data type that implemented a particular protocol, and it would be able to work with that data type.Good part is that it would not have to know anything else about that data type, allowing different data types to put their own spin on a piece of functionality.One of the most popular protocols in 3rd party libraries comes from the Json library, which encodes and decodes JSON data. In library sorce we can find protocal called Json Encoder. It defines single function encode with no definition.defprotocol JSON.Encoder do @moduledoc "..." @type t :: term @type opts :: Json.Encode.opts() @fallback_to_any true @doc "..." @spec encode(t, opts) :: iodata def encode(value, opts)endWhen the Protocol is implemented, other parts of library can call encode() and it will encode that data to JSON.JSON.Encoder.encode() # &lt;- pass in any data (string, integers, maps, list etc..)You may be wondering what is the point of this formality if we could write a function with multiple function heads that’s matches that type of data, likedef encode(value) when is_atom(value) do ...enddef encode(value) when is_binary(value) do ...enddef encode(value) when is_integer(value) do ...endafter all, we have guard classes for most data types in Elixir, the goal is extensibility.Having to implement a protocol for all types may quickly become monotonous and exhausting. You can define fallback behavior for types that don’t implement your protocol by implementing the protocol for Any. Let’s have a look in Json.Encode default implementation.defimpl JSON.Encoder, for: Any do  @moduledoc """  Falllback module for encoding any other values  """  @doc """  Encodes a map into a JSON object  """  def encode(%{} = struct) do    ...  end  def encode(x) do    ...  endendProtocol StructuringSome people include protocol in its own file and some include it in the same file as another module.My preferd way is to have a lib/protocols/ which contains actual protocol definitions. The organisation there follows the usual pattern but ommitting the first layer of the namespace. So if my protocol were Foo.Bar I’d put it into lib/protocols/bar.ex, also I’d put the defimpl for all native and foreign data types there.While I’d put the protocol implementation as close as possible to the data layer, in other words in the files that define the struct:defmodule Foo.Struct do  defstruct some_field: 0  defimpl Foo.Bar do    # actual implementation  endendSince, in the first part of this two-part series, we focused more on the theoretical part related to protocols, in the next part, we will focus more on the practical part and actually, see how the protocols work in reality and how we can implement them."
    } ,
  
    {
      "title"    : "Demistify elixir actor model",
      "article"  : "<div class='article col col-12 animate'> <div class='article__inner'> <div class='article__content'> <h2 class='article__title'> <a href='/demistify-elixir-actor-model'>Demistify elixir actor model<i class='ion ion-md-arrow-round-forward'></i></a> </h2> <div class='article__meta'> <time class='article__date' datetime='2021-12-01T13:01:35+01:00'>01 December 2021</time> – <span class='article__minutes'>9min read</span> </div><p class='article__excerpt'>Deep dive into what exactly the Actor Model is, and how exactly the Actor Model is implemented in Elixir/Erlang.</p><div class='article__bottom'><div class='article-tags__box'><a href='/tag/elixir' class='article__tag'>elixir</a></div></div></div></div></div>",
      "category" : "",
      "tags"     : "elixir",
      "url"      : "/demistify-elixir-actor-model",
      "date"     : "2021-12-01 13:01:35 +0100",
      "content"  : "In this blog post, I will try to demystify Elixir Actor Model and deep dive into what exactly the Actor Model is, and how exactly the Actor Model is implemented in Elixir/Erlang.To really understand these concepts, we will be writing code snippets to have a deeper understanding of the concept.What is the Actor Model?It’s a conceptual model of concurrent computation that originated in 1973. The actor model is designed to be a message-driven, non-blocking unit of computation. The actor model is not much different than a simple object and they have a few additional mechanisms that allow them to be message-driven and deal with messages that will be sent and delivered in an asynchronous way.An actor can hold its own state and can decide how to process the next message based on that state.The Actor Model is not the only concurrency model outside. Some of them are:     • CSP (Communication Sequential Processes) implemented in GO Language     • STM (Software Transactional Memory) implemented in Haskell     • TT-calculus and others…Actor Model on the BEAMIn the context of the BEAM, an actor is a process (not OS process) running in the Erlang virtual machine.Processes are isolated from each other, run concurrent to one another and communicate via message passing. Each process is compleatly separated from all the other process, it has a separate memory, garbage collector, nearly separate run time and the only way to communicate with the outside world is by sending messages to other processes located locally, or remotely on another connected Node.Messages and Mailboxes    Messages    • Messages in Elixir are asynchronous    • When you send a message to an actor, the message is placed instantly in the actor’s mailbox    • Actor process only one message by the time (FIFO)    Mailboxes    • Mailboxes in Elixir are lock-free queues    • Works asynchronously (doesn’t wait for response from another actor)Actor CreationAn actor is created by using the spawn function or the spawn_link function and it can create also an child actor.SpawnSpawn takes a function and returns a process identifier, aka a PID. The function passed to spawn takes no arguments and its structure is expected to be an infinite loop.All the messages are consumed via a receive block. receive block processes messages in the order received and allows messages to be pattern matched.Messages are sent to the processes using the send/2 function.actor = spawn fn -&gt;  receive do    {sender, :ping} -&gt; "Got ping"  endendsend(actor, {self, :ping}) #=&gt;  Got pingThis example above creates an actor that can only respond to a single message. That message MUST be the tuple {:ping}. Any other message is ignored.When the message {:ping} arrives, the actor prints out “Got ping” and thenthe function of the actor returns. That is interpreted as a normal exit, similar to having the run() method of a Java thread return.spawn_linkSimilar to spawn, spawn_link creates a new process, but links the current and new process so that if one crashes, both processes terminate.Linking processes is crucial  to the Elixir  philosophy of letting programs crash instead of trying to rescue from errors. With linking them we can better interactions with our actors.Linked actors get notified if one of them goes down(by either exiting normally or crashing). To receive this notification, we have to tell the system to trap the exit ofan actor; it then sends us a message in the form: {:EXIT, pid, reason} whenan actor goes down but ONLY if we start the process using spawn_link.Actor StateSince Elixir is immutable, you may be wondering how state is held. Actor state is nothing else than internal actor data, which can beaccessed directly only from an actor-owner. When one actor wants to read the data of another actor, it has to send a message and receive back the state. To maintain state in an actor, we can use pattern matching and recursion.defmodule Counter do def loop(count) do  receive do   {:next} -&gt;     IO.puts("Current count: #{count}")	     loop(count + 1)   end endendcounter = spawn(Counter, :loop, [1]) send(counter, {:next}) =&gt; # Current count: 1 send(counter, {:next}) =&gt; # Current count: 2Actor communicationSince an actor is a isolated process with internal state and mailbox, it has its own PID (process id), which is a unique actor identifier, used for message sender or receiver specification.Message passingFor direct message send it uses send function, which takes two arguments: PID of actor-receiver and the message itself. It runs asynchronously, so after this function invocation, actor will continue its execution.  send(other_actor_pid, message)Message receiveFor message receive it uses receive construction, which includes:    - Pairs &lt;msg pattern 1&gt; -&gt;&lt;related actions&gt;. If next message from mailbox matches to a given pattern, related actions is performed. Otherwise, actor waits for a new message matching to any other pattern    - Statement after, which specifies timeout for message delivery. If no new messages in mailbox in this time, the actor stops waiting and continues execution.defmodule Salutator do  def run do    receive do      {:hi, name} -&gt;        IO.puts "Hi, #{name}      {_, name} -&gt;        IO.puts "Hello, #{name}      after        1_000 -&gt; "nothing after 1s"    end  endend		 pid = spawn(Salutator, :run, [])send(pid, {:hi, "Mark"})  {:hi, "Mark"}=&gt; # Hi, Mark		send(pid, {:hello, "Suzie"})  {:hello, "Suzie"}=&gt; # Hello, SuzieParallelismParallelism means doing the same operations at the exact same time on independant data.In Elixir, processes are separate contexts (isolation) and you can have hundreds of thousands of processes on a single CPU (lightweight). If your computer has multiple cores, Elixir will run processes on each of them in parallel.    • Parallelism in actiondefmodule Parallel do  def map(collection, fun) do    parent = self()        processes = Enum.map(collection, fn(e) -&gt;     spawn_link(fn() -&gt;      send(parent, {self(), fun.(e)})     end)    end)    Enum.map(processes, fn(pid) -&gt;      receive do        {^pid, result} -&gt; result      end    end)  end endLet’s create some “heavy” function that will multiply numbers with one second delay..heavy_double = fn(x) -&gt; :timer.sleep(1000); x * 2 endIn sequential call the delay of one second occurred ten times and so the entire call to Enum.map took 10 seconds.:timer.tc(fn() -&gt; Enum.map([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], heavy_double) end)=&gt;  # {10010165, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]} &lt;= about 10 secondsIn parallel call process got launched per element of the input collection, they all waited one second, and then returned their result, so the entire call to Parallel.map took 1 second.:timer.tc(fn() -&gt; Parallel.map([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], heavy_double) end)=&gt; # {1001096, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]} &lt;= about 1 second Parallelism is fundamentally about taking something you can do in a sequential (one process/thread) program and making it faster by doing parts of it at the same time.SummaryAn actor in Elixir is called a process. You create new processes using one of the variants of the spawn function, send messages to it using the &lt;- operator, and receive messages using a receive expressionProcesses all contain a mailbox where messages are passively kept until consumed via a receive block. Actor State is internal actor data, which can be accessed directly only from an actor-owner. When one actor wants to read the data of another actor, it has to send a message and receive back the state."
    } 
  
]
